We consider static data structures which makes modifications to the data structures infeasible.

The algorithms we have focused on is classic binary search (in-order layout), binary tree (BFS), binary tree (DFS) and a blocked tree with BFS and DFS layout. All data structures are stored in single arrays.

For tree structures we always construct complete trees. In case the amount of data does not fill the tree, dummy data are used. The dummy data are MAX\_INT's. We never query MAX\_INT so we do not touch the dumma data. Thus the performance of the queries are not affected.

For each of the algorithms we theoretically analyzed the number of branch predictions and cache faults. The binary algorithms all have 50\% chance of a branch misprediction at each level and analysis of those are therefore omitted. We made the assumption that the cache is hot because we use a large number of queries in each test.

In the following sections we use these definitions:
\begin{eqnarray*}
\begin{array}{rcl}
n & : & \textrm{Number of 32 bit ints} \\
B & : & \textrm{Size of cacheline (in 32 bit ints)} \\
M & : & \textrm{Size of cache (in 32 bit ints)}
\end{array}
\end{eqnarray*}

\subsection{Binary search}

Contrary to the tree algorithms the binary search does not require any dummy data to be inserted.

\subsubsection*{Expected cache faults}

% TODO: Er -log2 B korrekt? Nok naermere 1/2 af det? Taenker man stadig kan hoppe udenfor?

\begin{eqnarray*}
\log_2 n - \log_2 B - \log_2 \frac{M}{B} 
\end{eqnarray*}
where $\log_2 B$ is the bottom where we make small jumps. The first elements we visit is far from each other so we need a whole cacheline for each. $\log_2 \frac{M}{B}$ is the "top" $\frac{M}{B}$ cachelines.

\subsection{Binary BFS layout}

...

\begin{eqnarray*}
\mathrm{left}(i) & = & 2i \\
\mathrm{right}(i) & = & 2i + 1
\end{eqnarray*}

\subsubsection*{Expected cache faults}

\begin{eqnarray*}
\log_2 n - \log_2 M 
\end{eqnarray*}
where $\log_2 M$ is the top of the tree.

\subsection{Binary DFS layout}

...

\begin{eqnarray*}
|L| & : & \textrm{Number of elements in left subtree} \\
\\
\mathrm{left}(i) & = & i + 1 \\
\mathrm{right}(i) & = & i + |L| + 1
\end{eqnarray*}

\subsubsection*{Expected cache faults}

\begin{eqnarray*}
(\frac{1}{2}\frac{1}{B} + \frac{1}{2})\log_2 n - \log_2 B - \log_2 M 
\end{eqnarray*}
where $\log_2 M$ is the top of the tree. $\log_2 B$ is the last few levels where $|L|$ gets small enough such that a subtree is smaller than a cacheline. $\frac{1}{2}\frac{1}{B}$ is when we go left and $\frac{1}{2}$ is when we go right.

\subsection{Blocked BFS layout}

The blocked BFS layout contains $d - 1$ elements per node/leaf where $d$ is the arity of the tree. These blocks are laid in a breadth-first layout.

\begin{eqnarray*}
d & : & \textrm{Arity of the tree} \\
j & : & \textrm{Element in block $i$ (leftmost: $0$)} \\
\\
\mathrm{element}(i, j) & = & d\cdot (i - 1) + j + 1
\end{eqnarray*}

\subsubsection*{Expected cache faults}

% TODO: Ikke dette billede

% TODO: Maaske bare tag simplere model, hvor d - 1 altid er power of two? Eksemplerne skulle meget gerne give det samme! Udover selvfoelgelig at dem der ikke er power of two skal slettes. I tilfaelde af at vi vaelger den model, saa kan det splittes op i 2 meget simple cases! Naar vi har en blok mindre end cacheline stoerrelse, og stoerre end.

\includegraphics[width=1\textwidth]{blocks}

\begin{eqnarray*}
X & : & \textrm{\#cacheline we end up in}\\
S & : & \textrm{\#a block's location from a cacheline boundary}\\
\\
m & = & \left\lfloor \frac{d-1+B-2}{B}\right\rfloor +1\textrm{ (\#max cachelines)}\\
\\
P(X=1\,|\, S=j) & = & \frac{\min\{B-j,\, d-1\}}{d-1}\\
\\
P(X=i\,|\, S=j) & = & \frac{B}{d-1}\\
\\
\underset{m\neq1}{P(X=m\,|\, S=j)} & = & 1-\sum_{i=1}^{m-1}P(X=i\,|\, S=j)\\
\\ % TODO: 
P(S=j) & = & \frac{P([d-1]_{B}\cdot[x]_{B}=j)}{\sum_{y=0}^{B-1}P([d-1]_{B}\cdot[x]_{B}=y)}\textrm{(\#possible congruence classes)}\\
\\
P(X=i) & = & \sum_{j=0}^{B-1}P(X=i\,|\, S=j)P(S=j)\\
\\
E(X) & = & \sum_{i=1}^{m}i\cdot P(X=i)
\end{eqnarray*}

\paragraph*{Cache faults}

$\log_{d}\, n\cdot E(X)-\log_{d}\frac{M}{d-1}$

where $\log_{d}\, n\cdot E(X)$ is the number of cache faults per level. But because we assume the cache is hot, the top of the tree ($\log_{d}\frac{M}{d-1}$) is in cache.

\subsubsection*{Example, $B=16,\, M=2^{14},\, n=10^{6}$}

\begin{tabular}{|c|c|}
\hline 
$d$ & Expected cache faults\tabularnewline
\hline 
\hline 
2 & 5.59\tabularnewline
\hline 
5 & 3.42\tabularnewline
\hline 
9 & 2.82\tabularnewline
\hline 
16 & 4.64\tabularnewline
\hline 
17 & 2.43\tabularnewline
\hline 
18 & 4.793\tabularnewline
\hline 
33 & 4.14\tabularnewline
\hline 
\end{tabular}
\\
\\
As we can see from the examples we should expect fewest cache faults when the block size is equal to the cacheline size. Furthermore, we can see that if blocks are not aligned with cacheline boundaries then the amount of cache faults increases.

\subsubsection*{Scanning}

Internally in the nodes we employed two different ways to scan through the elements. Linear scan and binary search.

% TODO: Mispredictions

\subsection{Blocked DFS layout}

As with the blocked BFS layout, this layout contains $d - 1$ elements per node/leaf where $d$ is the arity of the tree. These blocks are laid in a depth-first layout.

\begin{eqnarray*}
d & : & \textrm{Arity of the tree} \\
j & : & \textrm{Element in block $i$ (leftmost: $0$)} \\
|S| & : & \textrm{Number of elements in a subtree} \\
\\
\mathrm{element}(i, j) & = & i + j\cdot |S| + 1
\end{eqnarray*}

% TODO: Cache faults + mispredictions